// glossaryファイル Node
`use strict`
const glossary = [
{target:`CommonJS modules`, content:`モジュールの分割方法。比較的早く普及したため、npm等ですでに公開されているモジュールの多くで採用。拡張子に.js、.cjsを使用。<br>const fs = require('fs');`},
{target:`exports`, content:`CommonJS modulesのキーワード。ファイル単位に自動的に生成される変数に代入することで、関数や変数を外部に公開可能。module.exportsと併用できない。<br>calc.js<br>***.num = 1;<br>***.add = (a, b) => a + b;<br>index.js<br>const calc = require('./calc');<br>console.log(calc.num); → 1<br>let res = calc.add(3, 1); → 4 `},
{target:`require`, content:`CommonJS modulesのキーワード。モジュールを読み込む。パスを指定して読み込む場合.jsを省略可能。分割代入も可能。<br>calc.js<br>exports.num = 1;<br>exports.add = (a, b) => a + b;<br>index.js<br>const calc = ***('./calc');<br>console.log(calc.num); → 1<br>let res = calc.add(3, 1); → 4<br>const { add } = ***('./calc'); → 分割代入 `},
{target:`module.exports`, content:`CommonJS modulesのキーワード。他のファイルに公開したい変数や関数を指定する。複数の関数や変数をエクスポートしたい場合、オブジェクトを使ってまとめてエクスポートできる。exportsと併用できない。<br>calc.js<br>const add = (a, b) => a + b;<br>const subtract = (a, b) => a - b;<br>***.*** = {<br>&emsp;add: add,<br>&emsp;subtract: subtract<br>};<br>index.js<br>const calc = require('./calc');`},
{target:`ECMAScript modules`, content:`モジュールの分割方法。JavaScriptの標準として策定されたモジュールの方式。拡張子に.mjsを使用。<br>import fs from 'fs';`},
{target:`export`, content:`ECMAScript modulesのキーワード。変数や関数を外部に公開できる。export defaultと共存できる。<br>calc.mjs<br>*** const num = 1;<br>*** const add = (a, b) => a + b;<br>index.mjs<br>import { num, add } from './calc.mjs';<br>console.log(num); → 1<br>let res = add(3, 1); → 4 `},
{target:`import`, content:`ECMAScript modulesのキーワード。モジュールを読み込む。拡張子まで指定が必要。すべてのモジュールを読み込む場合は、asキーワードでモジュールに名前を付与した新しいオブジェクトとして読み込み可能。<br>calc.mjs<br>export const num = 1;<br>export const add = (a, b) => a + b;<br>index.mjs<br>*** { num, add } from './calc.mjs';<br>console.log(num); → 1<br>let res = add(3, 1); → 4<br>*** * as calc from './calc.mjs'; → すべてのモジュールを読み込む`},
{target:`as`, content:`ECMAScript modulesのキーワード。すべてのモジュールを読み込む。拡張子まで指定が必要。<br>calc.mjs<br>export const num = 1;<br>export const add = (a, b) => a + b;<br>index.mjs<br>import * *** calc from './calc.mjs'; → すべてのモジュールを読み込む`},
{target:`export default`, content:`ECMAScript modulesのキーワード。他のファイルに公開したい変数や関数を指定する。複数の関数や変数をエクスポートしたい場合、オブジェクトを使ってまとめてエクスポートできる。exportと共存が可能。<br>calc.mjs<br>*** *** function(){<br>&emsp;console.log('calc');<br>}<br>index.mjs<br>import defaultCalc from './calc.mjs';<br>defaultCalc(); → calcと表示`},
{target:`動的読込み（Dynamic Imports）`, content:`ECMAScript modulesの機能で、import()式にモジュールのパスを指定すると、import()式を読みだしたタイミングで初めてモジュールの読み込みが可能になる。<br>import('./calc.mjs)<br>&emsp;.then((module) => {<br>&emsp;&emsp;console.log(module.add(1, 2))<br>&emsp;});<br>document.querySelector('.addbutton').addEventListener('click', () => {<br>&emsp;import('./calc.mjs')<br>&emsp;&emsp;.then((module) => {<br>&emsp;&emsp;&emsp;const result = module.add(1, 2);<br>&emsp;&emsp;&emsp;document.querySelector('.result').innerText = result;<br>&emsp;&emsp;});<br>});`},
{target:`package.json`, content:`Node.jsプロジェクトの設定ファイル。プロジェクトに関する基本情報や依存関係、スクリプトなどを記述。プロジェクトを管理しやすくし、他の開発者がプロジェクトを簡単に理解・利用できるようにする。<br>***.***<br>{<br>&emsp;'type': 'module'<br>}<br>{<br>&emsp;'name': 'my-project', → プロジェクトの名前<br>&emsp;'version': '1.0.0', → プロジェクトのバージョン<br>&emsp;'description': 'これはサンプルのプロジェクトです', → プロジェクトの説明<br>&emsp;'main': 'index.js', → エントリーポイントとなるファイル<br>&emsp;'scripts': { → コマンドのスクリプト<br>&emsp;&emsp;'start': 'node index.js',<br>&emsp;&emsp;'test': 'echo \'No tests specified\' && exit 1'<br>&emsp;},<br>&emsp;'author': '名前', → プロジェクトの作者<br>&emsp;'license': 'ISC', → プロジェクトのライセンス<br>&emsp;'dependencies': { → プロジェクトが依存しているパッケージ<br>&emsp;&emsp;'express': '^4.17.1'<br>&emsp;}<br>}`},
{target:`dependencies`, content:`package.jsonのプロパティ。アプリケーションを構成するモジュールを記録。<br>$ cat package.json<br>{<br>&emsp;…<br>&emsp;'***': {<br>&emsp;&emsp;'marked': '^4.2.4',<br>&emsp;&emsp;'yargs': '^17.6.2'<br>&emsp;},<br>&emsp;'devDependencies': {<br>&emsp;&emsp;'eslint': '^8.29.0'<br>&emsp;}<br>&emsp;…<br>}`},
{target:`devDependencies`, content:`package.jsonのプロパティ。開発時に必要なモジュールを記録。<br>$ cat package.json<br>{<br>&emsp;…<br>&emsp;'dependencies': {<br>&emsp;&emsp;'marked': '^4.2.4',<br>&emsp;&emsp;'yargs': '^17.6.2'<br>&emsp;},<br>&emsp;'***': {<br>&emsp;&emsp;'eslint': '^8.29.0'<br>&emsp;}<br>&emsp;…<br>}`},
{target:`package-lock.json`, content:`node_modulesディレクトリを復元するために必要なファイル。npmが依存パッケージをインストールする際に生成される。`},
{target:`デュアルパッケージ`, content:`同じパッケージが異なる環境の両方で利用できるように設計されたもの。パッケージを1つだけ用意すれば、両方の環境で再利用できる。<br>package.json<br>{<br>&emsp;'exports': {<br>&emsp;&emsp;'import': './index.mjs',<br>&emsp;&emsp;'require': './index.cjs'<br>&emsp;}<br>}`},
{target:`npm（node package manager）`, content:`Node.jsのパッケージマネージャー。コードをホスティングするレジストリとそれを操作するCLIからなる。モジュールを利用・管理するためにはpackage.jsonが必要（例：private: trueとなるようなjsonファイルをディレクトリのルートに作成し、undiciをインストール）。<br>$ mkdir test_npm<br>cd test_npm<br>$ echo '{ 'private': true }' >> package.json → package.jsonの作成<br>cat package.json → package.jsonの内容表示<br>$ *** install undici --save → undiciのインストール<br>package.jsonの自動更新<br>{<br>&emsp;'private': true,<br>&emsp;'dependencies': {<br>&emsp;&emsp;'undici': '^5.14.0'<br>&emsp;}<br>}`},
{target:`npm install`, content:`npmのインストールコマンドを入力することで、package.jsonを参照し、アプリケーションが必要としているモジュールを一括で取得可能。<br>$ *** install undici --save → undiciのインストール`},
{target:`npm private`, content:`package.jsonのプロパティ。trueを設定することで、そのパッケージがプライベートであり、パブリックなリポジトリに公開されないようにすることができる。<br>$ echo '{ '***': true }' >> package.json → package.jsonの作成`},
{target:`リポジトリ`, content:`ソフトウェア開発においてソースコードや関連ファイルを管理するための場所やシステム。ソースコードのバージョン管理、共同開発、コードのバックアップなどのために使用。`},
{target:`依存ツリー`, content:`ソフトウェアプロジェクトの依存関係を木構造で表したもの。プロジェクトが直接依存しているパッケージやライブラリ（一次依存）だけでなく、それらのパッケージがさらに依存しているパッケージ（二次依存）なども含めて視覚的に示す。`},
{target:`npm scripts`, content:`package.jsonのプロパティ。プロジェクト内で共通して利用されるタスクなどをまとめる。タスクは、npm run xxxのようにnpm経由で呼び出すことが可能。また、preをつけたスクリプトはタスク直前に、postをつけたスクリプトはタスク直後に自動的に実行される。preinstallやpostinstallでモジュールのインストール前後に初期化処理を行うなど、プロジェクト内で共通の処理がある場合、ここに記述しておくと便利。<br>package.json<br>{<br>&emsp;'private': true,<br>&emsp;'***': {<br>&emsp;&emsp;'prebuild': 'echo 'pre build'',<br>&emsp;&emsp;'build': 'echo 'build'',<br>&emsp;&emsp;'postbuild': 'echo 'post build'',<br>&emsp;}<br>}`},
{target:`セマンティックバージョニング（Semantic Versioning, semver）`, content:`ソフトウェアのバージョン番号に意味を持たせる規則。バージョン番号を MAJOR.MINOR.PATCH の形式で表現し、それぞれに以下の意味を持たせる。<br>MAJOR: 後方互換性が壊れる変更<br>MINOR: 後方互換性のある機能追加<br>PATCH: 後方互換性のあるバグ修正`},
{target:`バージョニング`, content:`ソフトウェアやドキュメントの異なるバージョンを識別するための方法。`},
{target:`undici`, content:`高性能なHTTPクライアントライブラリ。イタリア語で'11'の意味（例：undiciを使用してYahooのウェブサイトからデータを取得するための非同期処理）。<br>$ npm install *** → インストール<br>const { request } = require('***');<br>request('https://www.yahoo.co.jp')<br>&emsp;.then((res) => {<br>&emsp;&emsp;return res.body.text()<br>&emsp;})<br>&emsp;.then((bodyText) => {<br>&emsp;&emsp;console.log(bodyText);<br>&emsp;})<br>&emsp;.catch((error) => {<br>&emsp;&emsp;console.error('Request failed:', error);<br>&emsp;});`},
{target:`undici request`, content:`undiciモジュールの関数。HTTPリクエストを送信し、レスポンスを処理できる（例：undiciを使用してYahooのウェブサイトからデータを取得するための非同期処理）。<br>const { *** } = require('undici');<br>***('https://www.yahoo.co.jp')<br>&emsp;.then((res) => {<br>&emsp;&emsp;return res.body.text()<br>&emsp;})<br>&emsp;.then((bodyText) => {<br>&emsp;&emsp;console.log(bodyText);<br>&emsp;})<br>&emsp;.catch((error) => {<br>&emsp;&emsp;console.error('Request failed:', error);<br>&emsp;});`},
{target:`イベントハンドリング`, content:`JavaScriptでイベント（ユーザーのアクションやシステムの状態変化など）が発生したときに、それに対する処理を記述する方法。`},
{target:`Callback`, content:`非同期処理を扱うための一般的な手法。関数を引数として渡し、処理が完了したときにその関数を呼び出す方法。ネストが深くなりがち、包括的なエラーハンドリングが行えない弱点がある。第一引数がエラーオブジェクトのため、エラーハンドリングは必ず第一引数のnullチェックが必要。try-cathでエラーを補足できないため、処理をネストしていく場合は、必ずそれぞれのネストでエラーのnullチェックが必要。この処理をPromiseオブジェクトでラップすることで、Promise化が可能。<br>const { readFile } = require('fs');<br>readFile(__filename, (err, data) => {<br>&emsp;if (err) {<br>&emsp;&emsp;console.error(err);<br>&emsp;&emsp;return;<br>&emsp;}<br>&emsp;console.log(data);<br>});`},
{target:`Callback Hell`, content:`非同期処理を扱う際に、コールバック関数を多重にネストしてしまうことで発生する問題。可読性が低下し、デバッグやメンテナンスが難しくなる。Promise、Async/Awaitなどを利用することで、コードをより読みやすく、メンテナンスしやすくする。`},
{target:`Promise`, content:`非同期処理を扱うオブジェクトで、処理の成功・失敗を返す。resolve（成功）とreject（失敗）時に呼び出す関数を引数にもつ関数をコンストラクタとして生成。成功した場合はthenメソッドの成功時のハンドラーを呼び出し、失敗した場合はchatchメソッドのハンドラーが呼び出される。<br>thenメソッド: 成功した場合の処理を定義。成功した結果を受け取り、処理を行う。<br>catchメソッド:失敗した場合の処理を定義。エラーを受け取り、エラーハンドリングを行う。<br>thenやcatchをつなぐこと（チェイン）が可能で、ネストが深くなることを防ぎ、包括的なエラーハンドリングが可能。<br>const fetchData = new ***((resolve, reject) => {<br>&emsp;setTimeout(() => {<br>&emsp;&emsp;const data = 'This is some data';<br>&emsp;&emsp;resolve(data); → thenメソッドの引数<br>&emsp;}, 1000);<br>});<br>fetchData<br>&emsp;.then(data => data + '!!'); → 'This is some data!!'が次のthenメソッドの引数に受け継がれる<br>&emsp;.then(data2 => {<br>&emsp;&emsp;console.log('Data received:', data2); → 'Data received: This is some data!!'を表示<br>&emsp;})<br>&emsp;.catch(error => {<br>&emsp;&emsp;console.error('Error occurred:', error);<br>&emsp;});`},
{target:`Promise then`, content:`JavaScriptのPromiseオブジェクトで非同期処理の結果を処理するために使うメソッド。非同期処理の結果を処理し、その結果を次の非同期処理の引数として渡すことで、非同期処理をチェーンすることができる。これにより、非同期処理が順番に実行され、各処理の結果が次の処理に渡されることが保証される。`},
{target:`Promise catch`, content:`Promiseチェーン内で発生したエラーをキャッチして処理する。具体的には、then()メソッドのチェーンの最後に配置され、前のPromiseで発生したエラーを受け取る。`},
{target:`Promiseのインターフェース`, content:`非同期操作の結果を表現するためのAPI。fsなどの標準モジュールは最初からPromiseのインターフェースが実装されている。Promiseは次の3つの状態を持つ。<br>Pending（保留中）: 非同期操作がまだ完了していない状態。<br>Fulfilled（達成済み）: 非同期操作が成功した状態。<br>Rejected（拒否された）: 非同期操作が失敗した状態。<br>then()、catch()、finally()などのメソッドを持ち、これらを使用して非同期操作の結果を処理する。<br>const fs = require('fs').promises;<br>fs.readFile('example.txt', 'utf8')<br>&emsp;.then(data => {<br>&emsp;&emsp;console.log('ファイルの内容:', data);<br>&emsp;})<br>&emsp;.catch(error => {<br>&emsp;&emsp;console.error('ファイルの読み込みエラー:', error);<br>&emsp;});<br><br>const { readFile, writeFile, chmod } = require('fs/promises');<br>const backupFile = __filename + '-' +Date.now();<br>readFile(__filename)<br>&emsp;.then((data) => {<br>&emsp;&emsp;return writeFile(backupFile, data);<br>&emsp;})<br>&emsp;.then(() => {<br>&emsp;&emsp;return chmod(backupFile, 0o400);<br>&emsp;})<br>&emsp;.catch((err) => {<br>&emsp;&emsp;console.error(err);<br>&emsp;});`},
{target:`コンストラクタ`, content:`オブジェクト指向プログラミングでクラスをインスタンス化する際に呼び出される特別なメソッド。`},
{target:`ハンドラー`, content:`イベントや要求などを処理するための関数やメソッド。`},
{target:`async/await`, content:`非同期処理を扱うためのキーワードで、より直感的で同期的なコードを書くことができる。Promiseを利用した非同期処理を同期的な見た目で記述でき、可能な限り推奨。asyncをつけた関数を宣言すると、その中にawaitを記述できる。awaitは続く式から返されたPromiseの結果が判明するまで、その部分の実行を中止する。そのため非同期処理をasync関数内では同期処理のように、順次、簡潔に記述できる。<br>async関数: 非同期処理を含む関数を定義。関数の前に async キーワードを付ける。<br>awaitキーワード: 非同期処理の実行を待つ。await キーワードを使うことで、非同期処理が完了するまで次の行の実行を待機。<br>try/catchブロック: try ブロックで非同期処理を試行し、catch ブロックでエラーをキャッチしエラーハンドリングを行う。<br>Promiseとasync/awaitは相互に呼び出しが可能。また、ループや条件分岐も同期コードのように直感的な記述が可能。また、async関数中ではtry-catchによるエラーハンドリングも可能。<br>const { readFile, writeFile, chmod } = require('fs/promises');<br>const main = async () => {<br>&emsp;const backupFile = __filename + '-' +Date.now();<br>&emsp;const data = await readFile(__filename)<br>&emsp;await writeFile(backupFile, data);<br>&emsp;await chmod(backupFile, 0o400);<br>&emsp;return 'done';<br>};<br>main()<br>&emsp;.then((data) => {<br>&emsp;&emsp;console.log(data);<br>&emsp;})<br>&emsp;.catch((err) => {<br>&emsp;&emsp;console.error(err);<br>&emsp;});`},
{target:`イベント駆動型非同期フロー制御`, content:`非同期操作が完了したときに特定の処理を実施。コールバック関数やイベントリスナーを使用。「処理の開始」「処理の途中」「処理の終了」「エラー発生時」などさまざまなタイミングで処理を実施。データを逐次処理することで目盛りを効率的に利用でき、イベントループを長時間停止させていしまう処理を分割したいといったケースで有効。`},
{target:`ストリーム処理`, content:`大きなデータを小さな塊に分割し、逐次的に処理する方法。これにより、メモリの使用量を最適化し、高速で効率的なデータ処理が可能。`},
{target:`EventEmitter`, content:`イベント駆動型プログラミングを実現するためのクラスで、イベントの発行とリスナーの登録を管理。on メソッドで特定のイベントにリスナーを登録し、emit メソッドでイベントを発行。ストリーム処理が必要な場合に推奨。代表的な処理には、HTTPリクエスト/レスポンス、TCP、標準入出力などがある。<br>const *** = require('events');<br>const myEmitter = new ***();<br>myEmitter.on('event', () => { → イベントに1つ目のリスナーを設定<br>&emsp;console.log('イベントが発生しました！');<br>myEmitter.on('event', (message) => { → イベントに2つ目のリスナーを設定<br>&emsp;console.log('イベントが発生しました！！' + message);<br>});<br>myEmitter.emit('event'); → イベントを発行`},
{target:`リスナー（Listener）`, content:`特定のイベントが発生したときに実行される関数。`},
{target:`イベント発行（イベント発火）`, content:`特定のイベントを発生させ、登録されているリスナーを実行する。`},
{target:`Stream`, content:`データをストリームとして扱うためのインターフェースで、非同期処理や大量のデータの処理に適している。ファイルやHTTPリクエストなどの入出力ストリームを扱う。createReadStream メソッドで読み取り可能なストリームを作成し、data イベントでデータを取得。エラー処理は error イベントで行う。EventEmitterにデータをため込む内部バッファを組み込んだもので、内部バッファに一定量のデータがたまると、イベントが発生。目盛りの使用量を抑えやすい。イベントのつなぎあわせ、データの流量の調整、変換処理など連続するデータの流れを効率的に扱うことが可能で、ストリーム処理が必要な場合に推奨。<br>const fs = require('fs');<br>const readableStream = fs.createReadStream('example.txt', 'utf8');<br>readableStream.on('data', (chunk) => {<br>&emsp;console.log('読み込んだデータ:', chunk);<br>});<br>readableStream.on('error', (error) => {<br>&emsp;console.error('エラーが発生しました:', error);<br>});<br>const main = async () => {<br>&emsp;for (let i = 0; i < 10; i++) {<br>&emsp;&emsp;const flag = await asyncFunction();<br>&emsp;&emsp;if (flag) {<br>&emsp;&emsp;&emsp;break;<br>&emsp;&emsp;}<br>&emsp;}<br>};`},
{target:`Stream Writable（fs.createWriteStream）`, content:`Streamの種別。データの書き込みに利用。writeとendメソッドの引数は、(chunk, [encoding], [callback])で、chunkは書込むデータ、encodingは文字列データのエンコーディング（省略可）、callbackは書込み完了したときに呼び出される関数（省略可）。endメソッドが呼び出されるとfinishイベントが発生。onメソッドの引数は、(event, listener)で、eventは監視するイベント名、listenerはイベント発生時に実行される関数（例：fs.createWriteStream()、output.txtファイルに書き込む）。<br>const fs = require('fs');<br>const writeStream = fs.createWriteStream('output.txt');<br>writeStream.write('Hello, world!');<br>writeStream.write('This is a test.');<br>writeStream.end();<br>writeStream.on('finish', () => {<br>&emsp;console.log('ファイルへの書き込みが完了しました。');<br>});<br>writeStream.on('error', (err) => {<br>&emsp;console.error('エラーが発生しました:', err);<br>});<br>`},
{target:`Stream Readable（fs.createReadStream）`, content:`Streamの種別。データの読み取りに利用。dataイベント：データ読取り開始、endイベント：データ読取り完了、errorイベント：エラー発生を受け取る（例：fs.createReadStream()、input.txtファイルからデータを読み取る）。<br>const fs = require('fs');<br>const readStream = fs.createReadStream('input.txt', 'utf8');<br>readStream.on('data', (chunk) => { → データ読取りごとにコールバック関数を実行<br>&emsp;console.log('読み取ったデータ:', chunk);<br>});<br>readStream.on('end', () => { → ファイル読取り完了ごとにコールバック関数を実行<br>&emsp;console.log('ファイルの読み取りが完了しました。');<br>});<br>readStream.on('error', (err) =>{ → エラー発生時にコールバック関数を実行<br>&emsp;console.error('エラーが発生しました:', err);<br>});`},
{target:`Stream Duplex`, content:`Streamの種別。書き込み/読み取りの両方に対応（例：net.Stocket、TCPソケットを作成し、読み取りと書き込みの両方を行う。ローカルホストの3000番ポートに接続するソケットを作成し、write()メソッドを使用してデータをサーバーに送信し、dataイベントを使用してサーバーからのデータを受信。また、endイベントとerrorイベントのハンドリング）。<br>const net = require('net');<br>const socket = net.connect({ port: 3000, host: 'localhost' });<br>socket.write('Hello, server!');<br>socket.on('data', (data) => {<br>&emsp;console.log('サーバーからのデータ:', data.toString());<br>});<br>socket.on('end', () => {<br>&emsp;console.log('接続が終了しました。');<br>});<br>socket.on('error', (err) => {<br>&emsp;console.error('エラーが発生しました:', err);<br>});`},
{target:`net.connect`, content:`netモジュールのメソッド。サーバーの接続に利用。指定されたポートとホストに対して新しいソケットを作成し、そのソケットを返す。portは接続先のポート番号を指定、hostは接続先のホスト名またはIPアドレスを指定。<br>const net = require('net');<br>const socket = ***.***({ port: 3000, host: 'localhost' }); → ローカルホストのポート番号3000に接続`},
{target:`ポート番号`, content:`コンピューターネットワーク上の通信において、ノード（プログラムやサービス）を識別するための番号。TCPやUDP通信において、送信元と受信先の両方が使用して通信を確立します。ポート番号は0から65535までの範囲で指定。HTTPのポート番号は80、HTTPSのポート番号は443、FTPのポート番号は20（データ転送）と21（制御）。同じホスト上で複数のアプリケーションが同じポート番号を使用しようとすると、ポート番号の衝突が発生する。`},
{target:`ソケット`, content:`通信の一方の端点を表す。通常、2つ揃うことで通信を確立、データの送受信が行わる。通信プロトコルによって定義され、通常はIPアドレスとポート番号の組み合わせで識別。`},
{target:`TCPソケット`, content:`Transmission Control Protocol (TCP) を使用して通信するためのソケット。信頼性の高いデータ転送を提供し、データが順序通りに届くことを保証。接続指向のプロトコルであり、通常はクライアントとサーバー間の双方向通信を確立するために使用。`},
{target:`ローカルホスト`, content:`自分自身を指す特別なホスト名。通常、IPv4アドレスでは「127.0.0.1」、IPv6アドレスでは「::1」にマッピング。これらのアドレスは、ローカルマシン上で動作しているプログラムやサービスにアクセスするために使用。同じコンピューター内で実行されているプログラムやサービスにアクセスすることができる。`},
{target:`Stream Transform`, content:`Streamの種別。Duplexを継承し、読み書きしたデータを変換する（例：zlib.createDeflate、データを圧縮するためのTransform Streamを作成。Deflateストリームを作成し、入力データを圧縮。dataイベントで圧縮されたデータを取得し、endイベントで圧縮が完了したことを検知。圧縮されたデータはBase64形式でログに出力）。<br>const zlib = require('zlib');<br>const input = 'Hello, world!';<br>const deflateStream = zlib.createDeflate();<br>deflateStream.write(input); → データを圧縮し、出力ストリームに書き込む<br>deflateStream.end();<br>let compressedData = Buffer.from(''); → 出力ストリームのデータを取得<br>deflateStream.on('data', (chunk) => {<br>&emsp;compressedData = Buffer.concat([compressedData, chunk]);<br>});<br>deflateStream.on('end', () => {<br>&emsp;console.log('圧縮されたデータ:', compressedData.toString('base64'));<br>});<br>deflateStream.on('error', (err) => { → 圧縮終了時の処理<br>&emsp;console.error('エラーが発生しました:', err);<br>});`},
{target:`libuv`, content:`バックエンドで使われるクロスプラットフォームの非同期I/Oライブラリ。libuvは、非同期イベントループ、ファイルシステムアクセス、ネットワーク通信などの機能を提供し、Node.jsの非同期処理やイベント駆動型のプログラミングを可能にする。また、libuvはマルチスレッド環境での効率的なイベントループの実装をサポート。`},
{target:`クロスプラットフォーム`, content:`複数の異なるプラットフォーム（オペレーティングシステムやデバイス）で動作するソフトウェアやツール。ソフトウェアは、1つのコードベースから複数のプラットフォームに対応し、異なる環境での動作を可能にする。これにより、開発者は効率的にソフトウェアを開発し、ユーザーは様々なプラットフォームで同じ機能を利用することができる。`},
{target:`fs`, content:`標準モジュール。ファイル作成/削除などの操作。<br>index.js<br>const fs = require('***');<br>***.readFile(__filename, (err, data) => {<br>&emsp;console.log(data);<br>});`},
{target:`fs __filename`, content:`fsモジュール内の特殊な変数。自身のファイル名を参照。<br>index.js<br>const fs = require('fs');<br>fs.readFile(***, (err, data) => {<br>&emsp;console.log(data);<br>});`},
{target:`fs readFile`, content:`fsモジュールの関数。非同期的にファイルを読み取る。指定されたファイルを非同期的に読み込み、コールバック関数を通じて読み込んだデータを返す。読み込むファイルのパスを指定し、オプションでエンコーディングやファイルの開き方を指定できる。コールバック関数では、第1引数でerrオブジェクトを受け取り（エラー発生しなかった時はnull）、第2引数でファイルから読み込まれたデータを受け取る。<br>const fs = require('fs');<br>fs.***('example.txt', 'utf8', (err, data) => { → example.txtファイルをutf8で読み込み、errとdataを引数で返す<br>&emsp;if (err) {<br>&emsp;&emsp;console.error('ファイルを読み込めませんでした:', err);<br>&emsp;&emsp;return;<br>&emsp;}<br>&emsp;console.log('ファイルの内容:', data);<br>});`},
{target:`fs writeFile`, content:`fsモジュールの関数。非同期的にファイルにデータを書き込むことができる。<br>const { readFile, ***, chmod } = require('fs/promises');<br>const backupFile = __filename + '-' +Date.now();<br>readFile(__filename)<br>&emsp;.then((data) => {<br>&emsp;&emsp;return ***(backupFile, data);<br>&emsp;})<br>&emsp;.then(() => {<br>&emsp;&emsp;return chmod(backupFile, 0o400);<br>&emsp;})<br>&emsp;.catch((err) => {<br>&emsp;&emsp;console.error(err);<br>&emsp;});`},
{target:`fs chmod`, content:`fsモジュールの関数。ファイルやディレクトリのパーミッション（アクセス権）を変更できる。0oで以降の3つの数字でアクセス権を設定（所有者、グループ、その他ユーザー）。読取り許可 +4、書込み許可 +2、実行許可 +1。<br>例<br>0o400：所有者のみ読取り権限を持つ。<br>0o755：所有者に全権限あり、グループとその他ユーザーは読取り、実行の権限を付与。<br>0o751：所有者に全権限あり、グループが読取りと実行の権限、その他ユーザーは実行のみ権限を持つ。<br>const { readFile, writeFile, *** } = require('fs/promises');<br>const backupFile = __filename + '-' +Date.now();<br>readFile(__filename)<br>&emsp;.then((data) => {<br>&emsp;&emsp;return writeFile(backupFile, data);<br>&emsp;})<br>&emsp;.then(() => {<br>&emsp;&emsp;return ***(backupFile, 0o400);<br>&emsp;})<br>&emsp;.catch((err) => {<br>&emsp;&emsp;console.error(err);<br>&emsp;});`},
{target:`AsyncIterator`, content:`非同期操作を逐次的に処理するためのインターフェース。複数回登場するイベント（dataなど）の非同期操作をfor...await...ofループで扱うことが可能。async/awaitとストリーム処理の相性を劇的に向上（例：readFileLines関数がファイルを読み込み、各行を非同期に生成。for await...ofループを使って、各行を逐次処理）。<br>const fs = require('fs').promises;<br>async function* readFileLines(filePath) {<br>&emsp;const data = await fs.readFile(filePath, 'utf8');<br>&emsp;const lines = data.split('\n');<br>&emsp;for (const line of lines) {<br>&emsp;&emsp;yield line;<br>&emsp;}<br>}<br>(async () => {<br>&emsp;for await (const line of readFileLines('example.txt')) {<br>&emsp;&emsp;console.log(line);<br>&emsp;}<br>})();<br><br>function* generator() {<br>&emsp;yield 'Hello';<br>&emsp;yield 'Generator';<br>}<br>const gen = generator();<br>console.log(gen.next().value); → Hello<br>console.log(gen.next().value); → Generator`},
{target:`ジェネレータ関数`, content:`yieldキーワードを使って複数の値を逐次的に返す。さらに、asyncと組み合わせることで、非同期ジェネレータ関数を定義し、非同期に複数の値を返すことができる。本来非同期のStreamを順次処理できるため（async/awaitにStreamを持ち込む）、try-catchなどのエラーハンドリングが可能。<br>yield: ジェネレータ関数や非同期ジェネレータ関数で、複数の値を逐次的に返すために使用<br>await: 非同期操作を待機するために使用し、非同期ジェネレータ関数の中で使用<br>for await...ofループ: 非同期イテレータを反復処理するために使用し、非同期ジェネレータ関数の値を逐次的に処理<br>async function* asyncGenerator() {<br>&emsp;yield await Promise.resolve('Hello');<br>&emsp;yield await Promise.resolve('Async');<br>&emsp;yield await Promise.resolve('Generator');<br>}<br>(async () => {<br>&emsp;for await (const value of asyncGenerator()) {<br>&emsp;&emsp;console.log(value);<br>&emsp;}<br>})();<br>`},
{target:`エラーハンドリング`, content:`プログラム中で発生する可能性のあるエラーを適切に処理するための方法。プログラムのクラッシュを防ぎ、エラーの情報を提供して対処できる。<br>同期処理：try-catchで囲う、async/awaitでラップ<br>Callback：if (err)<br>EventEmitter(Stream)：emitter.on('error')<br>async/await：try-catch, .catch()<br>AsyncIterator：try-catch, .catch()`},
{target:`Top-Level Await`, content:`ECMAScript modulesのみ。モジュールのトップレベルスコープでawaitを記述でき、非同期操作を簡単に行える。CLIツールなどで効果を発揮。<br>import { readFile } from 'fs/promises';<br>try {<br>&emsp;const data = await readFile('example.txt', 'utf8');<br>&emsp;console.log(data);<br>} catch (error) {<br>&emsp;console.error('ファイルの読み込みエラー:', error);<br>}`},
{target:`CLI（Command line interface）`, content:`コマンドラインインターフェースを通じて操作するツール。ユーザーがコマンドを入力して操作を実行。開発者がスクリプトを実行したり、システム管理者がタスクを自動化したりする際に利用。<br>特徴<br>コマンド入力: キーボードからコマンドを入力して操作。<br>スクリプト実行: 簡単なコマンドから複雑なスクリプトまで実行可能。<br>自動化: 繰り返しのタスクを自動化できる。`},
{target:`processオブジェクト`, content:`グローバルオブジェクトで、現在のNode.jsプロセスに関する情報や制御を提供。<br>主なプロパティとメソッド<br>process.argv: コマンドライン引数の配列。<br>process.env: 環境変数のオブジェクト。<br>process.cwd(): 現在の作業ディレクトリを取得。<br>process.exit([code]): プロセスを終了。終了コードを指定可能。<br>process.stdin: 標準入力のストリーム。<br>process.stdout: 標準出力のストリーム。<br>process.stderr: 標準エラー出力のストリーム。<br><br>argv.js<br>console.log(process.argv);<br><br>$ node argv.js one two=three --four → argv.jsに'one'、'two=three'、'--four'の引数を渡す<br>[ → process.argvの内容を表示<br>&emsp;'/usr/local/bin/node',<br>&emsp;'/home/xxx/dev/cli_test/argv.js',<br>&emsp;'one',<br>&emsp;'two=three',<br>&emsp;'--four'<br>]`},
{target:`yargs`, content:`CLIツールを簡単に作成するためのモジュール。コマンドライン引数の解析やコマンドの定義をサポートする。<br>主な機能<br>引数解析: コマンドライン引数を簡単に解析。<br>コマンド定義: 複数のコマンドを定義し、個別に処理。<br>オプションとフラグ: 短縮形と長い形のオプションをサポート。<br>ヘルプとバージョン: 自動的にヘルプとバージョン情報を生成。<br>.option('optionname'で指定すると、argvオブジェクトに説明やデフォルト値などを追加できる。<br>index.js<br>const path = require('path');<br>const fs = require('fs');<br>const yargs = require('***/***');<br>const { hideBin } = require('***/helpers'); → コマンドライン引数をパースするためのヘルパー関数<br>const { argv } = yargs(hideBin(process.argv)); → 3つ目以降の引数を取得<br>&emsp;.option('name', { → オプションの説明を追加<br>&emsp;&emsp;describe: 'CLI名を表示'<br>&emsp;})<br>&emsp;.option('file', {<br>&emsp;&emsp;describe: 'Markdownファイルのパス'<br>&emsp;})<br>console.og(argv) → 引数を表示<br>続きはyargs（2）に記載`},
{target:`yargs（2）`, content:`CLIツールを簡単に作成するためのモジュール（yargsの続き）。<br>const packageStr = fs.readFileSync(path.resolve(__dirname, 'package.json'), encoding: 'utf-8' });<br>const package = JSON.parse(packageStr); →  読み込んだファイルの内容をJSONオブジェクトに変換<br>if (argv.file) { → argvオプションのfileがあれば<br>&emsp;console.log(argv.file);<br>} else { if (argv.name) {<br>&emsp;console.log(package.name);<br>} else {<br>&emsp;console.log('オプションがありません');<br>}<br><br>$ node index.js --name → nameオプション取得確認<br>{ _:[], name: true, '$0': 'index.js'}<br>$ node index.js --version → package.jsonのバージョンを確認<br>1.0.0<br>`},
{target:`Markdownファイル`, content:`軽量マークアップ言語で書かれたテキストファイルで、.md拡張子を持ち、シンプルな書式で文書を記述し、HTMLに変換できる。<br>特徴<br>簡単な書式: プレーンテキストに記述、直感的な書式設定。<br>可読性: 生のテキストが読みやすく、編集が容易。<br>変換可能: HTMLやPDFなどに簡単に変換。<br>article.md → 作成したファイルは作業ディレクトリに配置<br># タイトル<br>hello!<br>**テスト**<br>'''javascript<br>const foo = 'bar';<br>'''<br>index.jsはMarkdownファイル（2）に記載`},
{target:`Markdownファイル（2）`, content:`軽量マークアップ言語で書かれたテキストファイルでHTMLに変換できる（Markdownファイルの続き）。<br>index.js<br>const path = require('path');<br>const fs = require('fs');<br>const yargs = require('yargs/yargs');<br>const { hideBin } = require('yargs/helpers');<br>const { argv } = yargs(hideBin(process.argv));<br>&emsp;.option('name', {<br>&emsp;&emsp;describe: 'CLI名を表示'<br>&emsp;})<br>&emsp;.option('file', {<br>&emsp;&emsp;describe: 'Markdownファイルのパス'<br>&emsp;})<br>if (argv.name)<br>&emsp;const packageStr = fs.readFileSync(path.resolve(__dirname, 'package.json'), encoding: 'utf-8' });<br>&emsp;const package = JSON.parse(packageStr);<br>&emsp;console.log(package.name);<br>&emsp;process.exit(0); → nameオプションがある場合、他のオプションを使わず正常終了させる<br>}<br>const markdownStr = fs.readFileSync(path.resolve(__dirname, argv.file), {encoding: 'utf-8 });<br>console.log(markdownStr);<br><br>$ node index.js --file=./article.md → markdownファイルの確認`},
{target:`ファイル分割`, content:`ファイルを分割し、コードの見通しをよくする。一部コードを関数化し、libディレクトリに切り出す。より保守性の高いコードにするためMarkdownファイルを読み込む関数では絶対パスを引数で受ける形にする。<br>directory/<br>&emsp;lib/<br>&emsp;&emsp;name.js → name関数<br>&emsp;&emsp;file.js → file関数<br>&emsp;article.md → markdownファイル<br>&emsp;index.js<br>&emsp;package.json<br>&emsp;package-lock.json<br>lib/name.js → name関数<br>const path = require('path');<br>const fs = require8'fs');<br>const packgeStr = fs.readFileSync(path.resolve(__dirname, '../package.json'), { encoding: 'utf-8' });<br>const package = JSON.parse(packageStr);<br>exports.getPackageName = () => {<br>&emsp;return package.name;<br>};<br>lib/file.js → file関数<br>const fs = require('fs');<br>exports.readMarkdownFileSync = (path) => {<br>&emsp;const markdownStr = fs.readFileSync(path, { encoding: 'utf-8' });<br>&emsp;return markdownStr;<br>};<br>index.jsはファイル分割（2）に記載`},
{target:`ファイル分割（2）`, content:`ファイルを分割し、コードの見通しをよくする（ファイル分割の続き）。<br>index.js<br>const path = require('path');<br>const yargs = require('yargs/yargs');<br>const { hideBin } = require('yargs/helpers');<br>const { getPakageName } = require('./lib/name');<br>const { readMarkdownFileSync } = require('./lib/file');<br>const { argv } = yargs(hideBin(process.argv));<br>&emsp;.option('name', {<br>&emsp;&emsp;describe: 'CLI名を表示'<br>&emsp;})<br>&emsp;.option('file', {<br>&emsp;&emsp;describe: 'Markdownファイルのパス'<br>&emsp;})<br>if (argv.name)<br>&emsp;const name = getPackageName();<br>&emsp;console.log(name);<br>&emsp;process.exit(0);<br>}<br>const markdownStr = readMarkdownFileSync(path.resolve(__dirname, argv.file));<br>console.log(markdownStr);<br><br>$ node index.js --file=./article.md → markdownファイルの確認`},
{target:`process.cwd()`, content:`processオブジェクトのメソッドで、現在の作業ディレクトリを返す。Webサービス等での利用には、実行するコンテキストで変わる変数の利用は、サーバーへの不正アクセスや情報漏洩のリスクがあり注意が必要。<br>const currentDir = ***.***(); → 現在の作業ディレクトリ`},
{target:`marked`, content:`npmモジュール。高速なMarkdownパーサーおよびコンパイラ。MarkdownファイルをHTMLに変換する。<br>$ npm install *** → インストール<br>const marked = require('***');<br>const markdownText = '# Hello, Markdown!\nThis is a paragraph.';<br>const htmlText = marked(markdownText); → MarkdownをHTMLに変換<br>console.log(htmlText);<br><br>lib/file.js<br>const fs = require('fs');<br>exports.readMarkdownFileSync = (path) => {<br>&emsp;const markdownStr = fs.readFileSync(path, { encoding: 'utf-8' });<br>&emsp;return markdownStr;<br>};<br>exports.writeHtmlFilesync = (path, html) => {<br>&emsp;fs.writeFileSync(path, html, { encoding: 'utf-8' });<br>};<br>index.jsはmarked（2）に記載`},
{target:`marked（2）`, content:`MarkdownファイルをHTMLに変換する。<br>index.js<br>const { marked}  = require('marked'); → markedを追加<br>const yargs = require('yargs/yargs');<br>const { hideBin } = require('yargs/helpers');<br>const { getPakageName } = require('./lib/name');<br>const { readMarkdownFileSync, writeHtmlFileSync } = require('./lib/file');<br>const { argv } = yargs(hideBin(process.argv));<br>&emsp;.option('name', {<br>&emsp;&emsp;describe: 'CLI名を表示'<br>&emsp;})<br>&emsp;.option('file', {<br>&emsp;&emsp;describe: 'Markdownファイルのパス'<br>&emsp;})<br>&emsp;.option('out', { → outオプションを追加<br>&emsp;&emsp;describe: 'html file',<br>&emsp;&emsp;default: 'article.html'<br>&emsp;]);<br>if (argv.name)<br>&emsp;const name = getPackageName();<br>&emsp;console.log(name);<br>&emsp;process.exit(0);<br>}<br>const markdownStr = readMarkdownFileSync(path.resolve(__dirname, argv.file));<br>console.log(markdownStr);<br>writeHtmlFileSync(path.resolve(__dirname, argv.out), html); → htmlをファイルに書き出し<br>$ node index.js --file=./article.md → markdownファイルの確認<br>cat article.html`},
{target:`prismjs`, content:`npmモジュール。軽量で拡張可能なシンタックスハイライター（構文強調表示ライブラリ）。HTML内のコードスニペットに色やスタイルを適用して、読みやすくするために使用。多くのプログラミング言語をサポートしており、カスタマイズも容易。<br>$ npm install *** → インストール<br>const Prism = require('***');<br>const loadLanguages = require('***/components/');<br>loadLanguages(['javascript', 'python']); → 必要な言語をロード<br>const code = '<br>def hello():<br>&emsp;print('Hello, world!')<br>';<br>const html = Prism.highlight(code, Prism.languages.python, 'python');<br>console.log(html);`},
{target:`eslint`, content:`静的解析ツールで、コードの品質を向上させるために使用。コーディングスタイルや構文エラーをチェックし、コードベースを一貫性のあるものに保つために役立つ。<br>$ npm install *** --save-dev → インストール<br>.eslintrc.js<br>module.exports = {<br>&emsp;env: {<br>&emsp;&emsp;commonjs: true,<br>&emsp;&emsp;es2021: true,<br>&emsp;&emsp;node: true<br>&emsp;},<br>&emsp;parserOptions: {<br>&emsp;&emsp;ecmaVersion: 12<br>&emsp;},<br>&emsp;rules: {<br>&emsp;&emsp;quotes: ['error', 'double'] → 例：ダブルクォートでないとエラーと表示<br>&emsp;}<br>&emsp;extend: 'eslint:recommended' → おすすめ設定の読み込み<br>};<br>pachake.json<br>{<br>&emsp;'script': {<br>&emsp;&emsp;'lint': 'eslint *.js lib/**/*.js', → npmのscriptsにショートカットを登録<br>&emsp;&emsp;'test': 'echo \'Error: no test specified\' && exit 1'<br>&emsp;},<br>}<br>$npm run lint → 登録した***を呼び出し`},
{target:`アサーション関数`, content:`プログラムの実行中に特定の条件が成り立つことを確認するための関数。テストやデバッグの際に使用され、期待される結果と実際の結果が一致するかどうかをチェックす。条件が満たされない場合、アサーション関数はエラーをスローする。`},
{target:`assert`, content:`条件が満たされていることを確認するために使用されるアサーション関数のモジュール。<br>const assert = require('***');<br>assert.equal(1, '1', '数値と文字列の比較'); → OK<br>assert.strictEqual(1, '1', '数値と文字列の比較（strict）'); → NG<br>assert.deepStrictEqual(obj1, obj2, 'オブジェクトの比較'); `},
{target:`テストランナー`, content:`テストケースを実行し、その結果を集計してレポートを生成。コードの変更が既存の機能を壊していないことを確認でき、品質の維持やバグの早期発見に役立つ。Jestやmochaなど。`},
{target:`jest`, content:`Reactアプリケーションのテストに適しているテストランナー。テストの実行管理だけでなく、モックやアサーション関数なども提供。test関数やexpect関数はjestコマンドを実行すると自動的にグローバルに追加される。<br>$ npm install --save-dev *** → インストール<br>sample.test.js<br>test('sample test', () => {<br>&emsp;expect(1 + 2), toStrictEqual(3);<br>});<br>$ npm test → *.test.jsファイルのテストを実行`},
{target:`prettier`, content:`コードのスタイルを統一し、可読性を向上させるコードフォーマッター（コード整形ツール）。JavaScript、TypeScript、HTML、CSS、Markdownなど、さまざまな言語をサポート。<br>$ npm install --save-dev *** → インストール<br>$ npx *** --write 'src/**/*.js' → srcディレクトリ内のすべてのJavaScriptファイルを整形`},
{target:`dayjs`, content:`軽量でモダンな日付と時間の操作モジュール。<br>$ npm install *** → インストール<br>const dayjs = require('***');<br>const str = dayjs(72021-01-23').format('YYYY/MM/DD');<br>console.log(str) → 2021/01/23`},
{target:`ネットワーク処理`, content:`ンピュータ間の通信を管理し、データの送受信を行うための処理。データパケットの作成、送信、受信、エラーチェック、接続の確立と管理などが含まれる。アプリケーションがインターネットやローカルネットワークを介して通信する際に不可欠。主要なプロトコルとしては、TCP/IP、UDP、HTTP、FTPなど。`},
{target:`データパケット`, content:`ネットワーク上でデータを送受信する際に、データを小さな単位に分割したもの。`},
{target:`APIサーバー`, content:`アプリケーションプログラムインターフェース（API）を通じて他のソフトウェアやサービスと通信するためのサーバー。クライアント（例えば、ウェブブラウザやモバイルアプリ）からのリクエストを受け取り、データベースや他のサービスと連携して必要なデータを取得し、その結果をクライアントに返す役割を果たす。ウェブサービスやマイクロサービスアーキテクチャにおいて重要なコンポーネント。`},
{target:`express`, content:`ウェブアプリケーションやAPIを構築するためのシンプルで柔軟なフレームワーク。ルーティング、ミドルウェア、テンプレートエンジンの統合など、ウェブアプリケーション開発に必要な基本的な機能を提供。迅速かつ効率的にサーバーサイドのアプリケーションを構築できる。<br>$ npm install *** → インストール<br>server.js<br>const *** = require('***');<br>const app = ***(); → サーバー用のインスタンスを作成<br>app.get('/', (req, res) => { → ルートを定義（ルーティング）<br>&emsp;res.status(200).send('hello world');<br>});<br>app.get('user/:id', (res, req) => {<br>&emsp;res.status(200).send(req.params.id);<br>});<br>app.listen(3000, () => { → ポート3000でサーバーを起動<br>&emsp;console.log('start listening');<br>});<br>$ node server.js → サーバー起動 → start listening<br>$ curl http://localhost:3000 → hello world<br>$ curl http://localhost:3000/user/foo → foo（:をつけてルート定義することで変数（req.prames.id → foo）として受け取り可能）`},
{target:`Express get`, content:`Expressのメソッド。特定のパスに対してクライアントからのデータ取得リクエストを処理するためのルートハンドラーを定義。引数(path, callback)は、path：リクエストのパス（例：'/'）、callback：ルートが一致したときに実行される関数。callbackの引数(req, res)は、req：リスエストオブジェクト、res：レスポンスオブジェクト。<br>const express = require('express');<br>const app = express(); → サーバー用のインスタンスを作成<br>app.***('/', (req, res) => { → ルートを定義（ルーティング）<br>&emsp;res.status(200).send('hello world');<br>});<br>app.***('user/:id', (res, req) => {<br>&emsp;res.status(200).send(req.params.id);<br>});<br>app.listen(3000, () => { → ポート3000でサーバーを起動<br>&emsp;console.log('start listening');<br>});<br>$ node server.js → サーバー起動 → start listening<br>$ curl http://localhost:3000 → hello world<br>$ curl http://localhost:3000/user/foo → foo（:をつけてルート定義することで変数（req.prames.id → foo）として受け取り可能）`},
{target:`req（リクエストオブジェクト）`, content:`HTTPリクエストに関する情報。<br>主なプロパティ<br>***.params：ルートパラメータ。URLの動的セグメントにマッチ<br>***.query：クエリパラメータ。URLのクエリストリングに含まれるデータ<br>***.body：リクエストボディ。POSTやPUTリクエストで送信されたデータ<br>***.headers：リクエストヘッダ。リクエストに含まれるメタデータ<br>app.get('/user/:id', (***, res) => {<br>&emsp;const userId = ***.params.id; → ルートパラメータ<br>&emsp;const queryParam = ***.query.name; → クエリパラメータ<br>&emsp;res.send('User ID: ' + userId + ' Query Name: ' +queryParam);<br>});<br>app.listen(port, () => { → サーバーを起動<br>&emsp;console.log('Server running at http://localhost:' + port);<br>});<br>$ curl http://localhost:3000/user/123?name=John → User ID: 123, Query Name: Johnと表示`},
{target:`res（レスポンスオブジェクト）`, content:`クライアントに送信されるレスポンスに関する情報。<br>主なメソッド・プロパティ<br>***.send()：レスポンスを送信。引数には文字列、JSONオブジェクト、またはバッファを指定<br>***.json()：JSON形式のデータを送信<br>***.status()：レスポンスのステータスコードを設定<br>***.setHeader()：レスポンスヘッダーを設定<br>***.redirect()：リダイレクト<br>***.offset()：オフセットを取得<br>app.get('/user/:id', (req, ***) => {<br>&emsp;const userId = req.params.id; → ルートパラメータ<br>&emsp;const queryParam = req.query.name; → クエリパラメータ<br>&emsp;***.send('User ID: ' + userId + ' Query Name: ' +queryParam);<br>});<br>app.listen(port, () => { → サーバーを起動<br>&emsp;console.log('Server running at http://localhost:' + port);<br>});<br>$ curl http://localhost:3000/user/123?name=John → User ID: 123, Query Name: Johnと表示`},
{target:`ステータスコード`, content:`HTTPプロトコルでクライアントとサーバーの間でやり取りされるリクエストおよびレスポンスの状態を示す3桁の数値。これは、クライアントがリクエストを正常に処理したか、エラーが発生したか、またはリダイレクトが行われたかなどを示す。<br>代表的なステータスコード<br>200：OK、リクエストが成功し、レスポンスが正常に返された<br>201：Created、リクエストが成功し、新しいリソースが作成された<br>204：No Content、リクエストが成功し、レスポンスにはコンテンツが含まれていない<br>400：Bad Request、クライアントのリクエストが不正であるため、サーバーが理解できない<br>401：Unauthorized、認証が必要なリソースに対するリクエストが認証されていない<br>403：Forbidden、クライアントがリソースにアクセスする権限がない<br>404：Not Found、リクエストされたリソースが見つからない<br>500：Internal Server Error、サーバーで予期しないエラーが発生`},
{target:`オフセット`, content:`位置や距離を示す数値であり、通常は基準点からの相対的な位置を表す。<br>ページネーション：ウェブページやアプリケーションで、大量のデータを複数のページに分割して表示する場合、各ページが開始するデータの位置を示すために使用<br>データベースクエリ：データベースから取得される結果セットのうち、最初の行からの相対的な位置を示すために使用。クエリ結果の一部のみを取得するために、スキップする行数を指定<br>レイアウト：グラフィックデザインやレイアウト設計のコンテキストでは、要素の位置を調整するために使用。テキストや画像の配置を微調整する場合に使用`},
{target:`Express listen`, content:`Expressのメソッド。指定したポートでリクエストを待ち受け、サーバーを起動する。HTTPリクエストを受け付け、適切なルートハンドラーにリクエストをルーティングすることが可能。<br>const express = require('express');<br>const app = express(); → サーバー用のインスタンスを作成<br>app.get('/', (req, res) => { → ルートを定義（ルーティング）<br>&emsp;res.status(200).send('hello world');<br>});<br>app.get('user/:id', (res, req) => {<br>&emsp;res.status(200).send(req.params.id);<br>});<br>app.***(3000, () => { → ポート3000でサーバーを起動<br>&emsp;console.log('start listening');<br>});<br>$ node server.js → サーバー起動 → start listening<br>$ curl http://localhost:3000 → hello world<br>$ curl http://localhost:3000/user/foo → foo（:をつけてルート定義することで変数（req.prames.id → foo）として受け取り可能）`},
{target:`ルートハンドラー`, content:`Expressアプリケーションで特定のURLパスに対するリクエストを処理する関数。app.get()、app.post()などのHTTPメソッドと組み合わせて使用され、特定のURLに対してリクエストが送信されたときに実行される処理を定義。クライアントからのリクエストに対してデータを処理し、適切なレスポンスを生成する役割を果たす。`},
{target:`ルーティング`, content:`ExpressアプリケーションでクライアントからのHTTPリクエストを、それに対応するハンドラー関数にマッピングするプロセス。具体的には、特定のURLパスに対してどのような処理を行うかを定義し、その処理を実行するための関数を割り当てる。これにより、ウェブアプリケーションはリクエストを受け取り、適切なレスポンスを返すことが可能。`},
{target:`ミドルウェア`, content:`Expressアプリケーションにおいて、リクエストとレスポンスの間で動作する関数。HTTPリクエストを処理する前や後に特定の処理を実行するために使用（例：ログ記録、認証、セッション管理、エラーハンドリングなど）。app.getやapp.use()メソッドを使用してアプリケーションに追加され、リクエストのパイプライン内で順番に実行される（順に並べることで連鎖的に呼び出しも可能）。これにより、リクエストとレスポンスの処理を柔軟かつ効率的にカスタマイズすることが可能になる。次のを呼び出す場合は第3引数に渡されるnextという関数を用いる（例：リクエストが発生するたびに、リクエストのHTTPメソッドとURLをコンソールにログとして出力）。<br>const express = require('express');<br>const app = express();<br>app.use((req, res, next) => { → リクエストログを出力するミドルウェアをアプリケーションに追加<br>&emsp;console.log('[' + new Date() + ']' + ' ' + req.method + ' ' + req.url);<br>&emsp;next(); → 次のミドルウェアまたはルートハンドラーに処理を委譲<br>});<br>app.get('/', (req, res) => { → ルートハンドラー<br>&emsp;res.send('Hello World!');<br>});<br>app.listen(3000, () => { → サーバーを起動<br>&emsp;console.log('Server is listening on port' + port);<br>});<br>$ curl http://localhost:3000/<br> → Server is listening on port 3000<br> → [Thu Mar 24 2022 13:42:22 GMT+0000 (Coordinated Universal Time)] GET /<br> → Hello World!`},
{target:`包括的エラーハンドリング`, content:`Expressアプリケーションにおいて、特殊なミドルウェアとして、エラーが発生した際に、そのエラーを適切にキャッチして処理する仕組み。4つの引数があることが条件で呼び出される。第1引数にエラー内容、第2引数にリクエスト、第3引数にレスポンス、第4引数にnextをとる。アプリケーション全体で一貫した方法でエラーを処理。app.getやapp.useの最後に呼ばれるように定義。<br>server.js<br>const express = require('express');<br>const app = express();<br>app.get('/', (req,res) => { → ルーティングとミドルウェア<br>&emsp;res.status(200).send('hello world!!');<br>});<br>app.use((err, req, res, next) => { → 包括的エラーハンドリング<br>&emsp;res.status(500).send('Internal Server Error');<br>});<app.listen(3000, () => {<br>&emsp;console.log('start listening');<br>});`},
{target:`Redis（Remote Dictionary Server）`, content:`オープンソースのインメモリデータ構造ストアであり、主にデータベース、キャッシュ、メッセージブローカーとして利用。主にメモリ内でデータを保持し、非常に高速な読み書き操作を提供し、多様なデータ構造（文字列（Strings）、リスト（Lists）、セット（Sets）、ソート済みセット（Sorted Sets）、ハッシュ（Hashes）、ビットマップ（Bitmaps）、ハイパーログログ（HyperLogLog）、ストリーム（Streams）など）をサポート。<br>主な特徴<br>高速性：メモリ内にデータを保持するため、非常に高速な読み書き操作が可能<br>永続性：データをディスクに保存する機能があり、再起動後もデータを保持<br>スケーラビリティ：分散型クラスター構成をサポートし、データを分散して管理可能<br>多様な用途：キャッシュ、セッション管理、リアルタイム分析、ランキングシステム、メッセージキューなど、さまざまな用途に利用`},
{target:`ioredis`, content:`Node.js用のRedisクライアントモジュール。シンプルなAPIで、非同期I/Oを利用して効率的なパフォーマンスを提供。クラスターサポートやSentinelサポート、スクリプト実行、イベント駆動が可能。<br>$ npm install ioredis → インストール<br>server.js<br>const Redis = require('***');<br>const express = require('express');<br>const app = express();<br>const redis = new Redis({ → Redis接続部分。インスタンス作成時に接続先情報を渡す<br>&emsp;port: 6379,<br>&emsp;host: 'localhost',<br>&emsp;password: process.env.REDIS_PASSWORD, → 環境変数にパスワードを渡す<br>&emsp;enableOfflineQueue: false → false：Redis利用に関わらずサーバーが起動するのを防ぐ<br>});<br>app.get('/', (req, res) => {<br>&emsp;res.status(200).send('hello world');<br>});<br>app.get('user/:id', (req, res) => {<br>&emsp;res.status(200).send(req.params.id);<br>});<br>redis.once('ready', () => { → サーバー立ち上げ（1度しか行わないので'on'ではなく'once'）。利用可能で発行されるreadyイベントに処理を紐づけ<br>&emsp;try {<br>&emsp;&emsp;app.listen(3000, () => {<br>&emsp;&emsp;&emsp;console.log('start listening');<br>&emsp;&emsp;});<br>&emsp;} catch (err) {<br>&emsp;&emsp;console.error(err);<br>&emsp;&emsp;process.exit(1);<br>&emsp;}<br>});<br>redis.on('error', (err) => {<br>&emsp;console.error(err);<br>&emsp;process.exit(1);<br>});`},
{target:`process.env`, content:`Node.jsで環境変数にアクセスするためのオブジェクト。パスワードのようなクレデンシャルな情報をコードに渡すには環境変数を利用する。***.***.DB_HOST：データベースホストのURL。***.***.REDIS_PASSWORDは、Node.jsアプリケーションで環境変数REDIS_PASSWORDにアクセスするためのプロパティで、Redisサーバーに接続する際のパスワードを含む環境変数。コードに直接パスワードを記述せずに、環境変数からセキュアに取得できる。`},
{target:`process.exit`, content:`Node.jsプロセスを異常終了させるためのメソッド。引数には終了コードを指定。<br>主な終了コード<br>0：正常終了を示す。通常はエラーなしでプログラムが完了した場合に使用<br>1：一般的な異常終了を示す。エラーが発生したか、または予期しない条件が発生した場合に使用<br>2：コマンドライン引数が不正であるなど、不正な使用方法が原因でプログラムが終了した場合に使用<br>redis.on('error', (err) => {<br>&emsp;console.error(err);<br>&emsp;process.exit(1);<br>});`},
{target:`環境変数`, content:`オペレーティングシステムが管理する変数で、アプリケーションの設定情報を外部から提供するために使用。`},
{target:`クレデンシャル`, content:`システムやサービスにアクセスするための認証情報。ユーザー名やパスワード、APIキー、トークンなど。これらの情報を使用して、システムはユーザーやアプリケーションの身元を確認し、適切なアクセス権を付与する。`},
{target:`ioredis enableOfflineQueue`, content:`ioredisの設定オプション。Redisサーバーとの接続が切れた際にコマンドをキューに保存するかどうかを制御。<br>true（デフォルト）：Redisサーバーとの接続が切れている間に送信されたコマンドをキューに保存し、接続が回復した後に再送信<br>false：接続が切れている間に送信されたコマンドを即座に失敗させる。これによりRedisが利用できない状況でサーバーが起動するのを防ぐ`},
{target:`ioredis once`, content:`ioredisライブラリで提供されるイベントリスナーを登録するためのメソッド。指定されたイベントが最初に発生したときにのみコールバック関数を実行。<br>redis.***(eventName, listener) → eventNameはイベント（ioredis イベント参照）`},
{target:`ioredis on`, content:`ioredisライブラリで提供されるイベントリスナーを登録するためのメソッド。指定されたイベントが最初に発生したときにコールバック関数を実行。<br>ioredis.***(eventName, listener) → eventNameはイベント（ioredis イベント参照）`},
{target:`ioredis イベント`, content:`ioredisでよく使用されるイベント。<br>redis.on(eventName, listener) → eventNameはイベントを示す<br>主なイベント<br>'connect'：Redisサーバーへの接続が確立されたときに発生<br>'ready'：Redisクライアントが使用可能な状態になったときに発生<br>'error'：エラーが発生したときに発生<br>'close'：Redis接続が閉じられたときに発生<br>'reconnecting'：Redisクライアントが再接続中であるときに発生<br>'end'：Redis接続が終了したときに発生<br>'message'：RedisのPUB/SUBモードでメッセージが受信されたときに発生<br>'subscribe'：RedisのPUB/SUBモードでチャンネルがサブスクライブされたときに発生<br>'unsubscribe'：RedisのPUB/SUBモードでチャンネルのサブスクリプションが解除されたときに発生<br>'monitor'：Redisのモニターモードでコマンドが実行されたときに発生`},
{target:`ioredis set`, content:`ioredisのメソッド。Redisデータベースにキーと値のペアを保存する（例：サーバー起動時に初期化処理でユーザーのデータを作成し、そのデータを/usersで表示）。<br>redis.***(key, value, [callback]) → key：保存するデータのキー、value：値、callback：処理完了時に呼び出されるコールバック関数<br>server.js<br>const Redis = require('ioredis');<br>const express = require('express');<br>const app = express();<br>const redis = new Redis({ → Redis接続部分。インスタンス作成時に接続先情報を渡す<br>&emsp;・・・<br>});<br>const init = async () => { → Redisに初期データをセット<br>&emsp;await Promise.all({ → Promise.allで同時にセット<br>&emsp;&emsp;redis.set('users:1', JSON.stringify({ id: 1, name: 'alpha' })),<br>&emsp;&emsp;redis.set('users:2', JSON.stringify({ id: 2, name: 'bravo' })),<br>&emsp;&emsp;redis.set('users:3', JSON.stringify({ id: 3, name: 'charlie' }))<br>});<br>・・・<br>redis.once('ready', async() => {<br>&emsp;try {<br>&emsp;&emsp;await init(); → initを実行<br>&emsp;&emsp;・・・<br>});<br>・・・<br>$ node server.js<br>docker run -it --net host redis redis-cli -h localhost -p 6379<br>localhost:6379> key *<br>1) 'users:3'<br>2) 'users:2'<br>3) 'users:1'<br>localhost:6379> get users:1<br>'{\'id\':1,\'name\':\'alpha\'}'`},
{target:`ioredis get`, content:`ioredisのメソッド。Redisデータベースから指定されたキーに関連付けられた値を取得（例：ユーザーIDを指定して取得する/user/:idを作成）。<br>redis.***(key, [callback]) → key：取得したいデータのキー、callback：処理完了時に呼び出されるコールバック関数<br>server.jsない、app.listenの前に追記<br>app.get('/user/:id', async (req, res) => {<br>&emsp;try {<br>&emsp;&emsp;const key = 'users:' + req.params.id;<br>&emsp;&emsp;const val = await redis.***(key);<br>&emsp;&emsp;const user = JSON.parse(val);<br>&emsp;&emsp;res.status(200).json(user);<br>&emsp;} catch (err) {<br>&emsp;&emsp;console.error(err);<br>&emsp;&emsp;res.status(500).send('internal error');<br>&emsp;}<br>});`},
{target:`ioredis scanStream`, content:`ioredisのメソッド。Redisデータベースのキーをスキャンするためのストリームを提供。大量のキーを一度に取得することができ、メモリ効率が向上する（例：ユーザーデータをすべて取得する/usersを作成）。<br>const stream = redis.***(options) → options：スキャンのオプションを指定するオブジェクト。デフォルトは空オブジェクト{}<br>server.js内、app.listenの前に追記<br>app.get('/users', async (req, res) =>{<br>&emsp;try {<br>&emsp;&emsp;const stream = redis.***({<br>&emsp;&emsp;&emsp;match: 'users:*', → 'users:'で始まるキーのみをスキャン<br>&emsp;&emsp;&emsp;count: 2 → 1回の呼出しで2つ取出す<br>&emsp;&emsp;});<br>&emsp;&emsp;const users = [];<br>&emsp;&emsp;for await (const resultKeys of stream) {<br>&emsp;&emsp;&emsp;for (const key of resultKeys) {<br>&emsp;&emsp;&emsp;&emsp;const value = await redis.get(key);<br>&emsp;&emsp;&emsp;&emsp;const user = JSON.parse(value);<br>&emsp;&emsp;&emsp;&emsp;users.push(user);<br>&emsp;&emsp;&emsp;}<br>&emsp;&emsp;}<br>&emsp;&emsp;res.status(200).json(users);<br>&emsp;} catch (err) {<br>&emsp;&emsp;console.error(err);<br>&emsp;&emsp;res.status(500).send('internal error');<br>&emsp;}<br>});`},
{target:`ページング処理`, content:`大量のデータを複数のページに分割して表示するための方法。ウェブアプリケーションやデータベースクエリなどで使用。ユーザーは大量のデータを一度に表示せず、ページごとにデータを見ることができる。オフセットとリミットを使用して、特定のページのデータを取得。オフセットはデータの開始位置、リミットは各ページに表示されるデータの数。ユーザーがデータを操作するための直感的な方法を提供し、大量のデータを効果的に処理するための手段を提供するという利点がある。`},
{target:`prefix`, content:`文字列やパターンの先頭部分。*はワイルドカードとして使用され、任意の文字列にマッチする。<br>users:* → 'users:'で始まる任意の文字列`},
{target:`ioredis lrange`, content:`ioredisのメソッド。Redisのリスト（List）データ型から指定された範囲の要素を取得。ページング処理（例：ユーザーの表示部分をページング処理に変更）。<br>redis.***(key, start, stop, [callback]) → key：リストのキー、start：開始インデックス、stop：終了インデックス、callback：取得した要素が渡されるコールバック関数<br>ユーザー情報をリスト型に変更<br>const init = async () => {<br>&emsp;await redis.rpush('users:list', JSON.stringify({ id: 1, name: 'alpha' }))<br>&emsp;await redis.rpush('users:list', JSON.stringify({ id: 2, name: 'bravo' }))<br>&emsp;await redis.rpush('users:list', JSON.stringify({ id: 3, name: 'charlie' }))<br>};<br>・・・<br>app.get('/users', async (req, res) => {<br>&emsp;const offset = req.query.offset ? Number(req.query.offset) : 0;<br>&emsp;const usersList = await redis.***('users:list', offset, offset + 1); → クエリパラメータにoffsetを指定すると、指定した箇所からデータを取得<br>&emsp;const users = usersList.map((user) => {<br>&emsp;&emsp;return JSON.parse(user);<br>&emsp;});<br>&emsp;return { users: users };<br>});`},
{target:`ioredis rpush`, content:`ioredisのメソッド。Redisのリスト（List）データ型の末尾に要素を追加。リストの末尾に追加されるため、リストの順序は維持される。<br>redis.***(key, value1, value2, ..., [callback]) → key：リストのキー、value：追加する要素、callback：操作が完了した時に呼び出されるコールバック関数`},
{target:`AAAAAAAAAAAA`, content:`AAAAAAAAAAAAAAAA`},
{target:`path`, content:`標準モジュール。ファイルやディレクトリパスなどのユーティリティ機能。`},
{target:`http/https`, content:`標準モジュール。http/httpsサーバーやクライアントの機能。<br>const http = require('http');<br>http → httpサーバーの生成（例：3000番ポートをlistenするHTTPサーバー）。<br>&emsp;.createServer((req, res) => {<br>&emsp;&emsp;res.write('hello world');<br>&emsp;&emsp;res.end();<br>&emsp;})<br>&emsp;.listen(3000) `},
{target:`os`, content:`標準モジュール。CPUの数やホスト名などOS関連情報の取得。`},
{target:`child_process`, content:`標準モジュール。子プロセス関連の機能。`},
{target:`cluster.worker_threads`, content:`標準モジュール。マルチコア、プロセスを利用するための機能。`},
{target:`crypto`, content:`標準モジュール。OpenSSLのハッシュや暗号・署名や検証などの暗号化の機能。`},
{target:`assert`, content:`標準モジュール。アサーション（変数や関数の検証）の機能。`},
{target:`コンテキスト`, content:`実行される場所。thisの値に影響を与える。`},
{target:`関数コンテキスト`, content:`関数内での this の値は、関数の呼び出し方によって異なる。関数の呼び出し時に this の値を特定の値に設定するには、call() またはapply()を使用する。`},
{target:`ランタイム`, content:`実行環境`},
{target:`フロントエンド`, content:`面表示や入力・操作の受け付けなど、主に利用者が直接触れる部分。`},
{target:`バックエンド`, content:`フロントエンドから受け取ったデータを処理・保存したり、フロントエンドの要求に応じてデータや機能を提供する構成要素。`},
{target:`同期処理`, content:`同時に1つのタスクしか実行されない。`},
{target:`非同期処理`, content:`同時に複数のタスクを処理する。`},
{target:`イベント駆動形`, content:`発行されるイベントを下敷きにさまざまな処理を行う特徴。`},
{target:`Non-Blocking I/O`, content:`I/O（入出力）をブロッキングしないこと。`},
{target:`I/O（Input/Output）`, content:`入出力。`},
{target:`キュー`, content:`先頭が常に最も古い要素になるデータ構造で、新しい要素は必ず末尾に追加される。取り出すときは常に先頭の最も古い要素から取り出される。`},
{target:`イベントループ`, content:`プログラムが新たなイベントを待ち続ける状態。`},
{target:`アイドル`, content:`使用されていない、何の処理も行っていない、すぐ使用できるよう待機などの状態。`},
{target:`スレッド`, content:`並行処理に対応したマイクロプロセッサ（CPU/MPU）およびオペレーティングシステム（OS）におけるプログラムの最小の実行単位。`},
{target:`シングルスレッド`, content:`プログラムの処理の流れが一本のみである状態。`},
{target:`マルチスレッド`, content:`一つのコンピュータプログラムを実行する際に、複数の処理の流れを並行して進めること。また、そのような複数の処理の流れ。`},
{target:`プロセス`, content:`実行されているプログラムを管理する単位。`},
{target:`C10K問題`, content:`Apache HTTP ServerなどのWebサーバソフトウェアとクライアントの通信において、クライアントが約1万台に達すると、Webサーバーのハードウェア性能に余裕があるにもかかわらず、レスポンス性能が大きく下がる問題。Apacheはクライアントの接続一つ一つに対してプロセスを生成する仕様となっている。そのため大量のクライアントから接続があった場合、その数だけプロセスを生成しなければならない。しかし、WindowsあるいはLinuxなどのUNIX系OSでは、同時に起動できるプロセスに32767(2^15-1)個の制限がある。この制限を超えるとプロセスを新規生成することができなくなるため、既にあるリクエストの処理が終わるまで新たな接続は待たなければならない。回避には、サーバーサイドでNode.jsなどの駆動方式を持ったソフトウェアを使用する。`},
{target:`バンドル`, content:`複数のファイルを一つにまとめること。単体でも提供可能な製品やサービスを、複数組み合わせてセットで販売したり、別の製品やサービスに付属して販売、提供すること。`},
{target:`バンドラー`, content:`ファイルをバンドルするツールやソフト。`},
{target:`nan`, content:`nan`},
{target:`パッケージ`, content:`一つのソフトウェアを構成する実行プログラムやソースコード、設定ファイル、データファイル、ドキュメントなどを特定の形式の圧縮ファイルなどにまとめたもの。`},
{target:`パッケージマネージャー`, content:`リポジトリに接続してパッケージの一覧を取得し、利用者が指示したパッケージを取り寄せて自動的に展開、導入（インストール）して実行可能な状態にする。`},
{target:`リポジトリ`, content:`ソフトウェア開発などに用いるバージョン管理システムやプロジェクト管理システムなどで、プロジェクトを構成するプログラムのソースコードやドキュメント、関連する各種のデータやファイルなどを一元的に管理する格納場所。`},
{target:`ホスティング`, content:`通信事業者やインターネットサービスプロバイダが提供するサーバーのレンタルサービス。`},
{target:`レジストリ`, content:`Windowsでシステム（OS）やアプリケーションソフトの設定データなどを一元管理するデータベース。ストレージ内のシステムドライブに保管されている。各項目はキー（key、項目名）と値（value）を一対一に対応付けたセットとして記録されている。値にはいくつかのデータ型が用意されており、文字列を格納できる文字列値や、任意のバイト列を格納できるバイナリ値、32ビットのビット列を格納できるDWORD値などが利用できる。`},
{target:`トランスパイル`, content:`あるプログラミング言語で書かれたプログラムを、別のプログラミング言語のプログラムに変換すること。`},
{target:`SSR（Server Side Rendering）`, content:`フロントエンドで生成されるページを、サーバーサイドで事前にレンダリングしてHTMLとして準備する。`},
{target:`レンダリング`, content:`何らかのデータ形式やデータ構造で記述された描画内容を表すデータ群をソフトウェアが読み込み、内容を解釈して画像や動画、音声などを生成する。結果をそのまま即座に画面に表示することを指すが、生成結果を何らかのデータ形式でファイルなどに記録・保存したり、ネットワークを介して別のコンピュータに送信・配信することを含む場合もある。`},
{target:`BFF（Backend For Frontend）`, content:`フロントエンドのために複数のAPIなどを束ねる役割を持つバックエンド。`},
{target:`コンテキストスイッチ`, content:`コンピュータの処理装置（CPU）が現在実行している処理の流れ（プロセス、スレッド）を一時停止し、別のものに切り替えて実行を再開すること。あるプロセスを実行している最中に、処理を中断してCPU内部のレジスタの状態などを特定のメモリ領域などに保存し、同じように途中で中断されていた別のプロセスの実行状態を読み込んで処理を再開する。複数のプロセスを並行に実行することができる。`},
{target:`モジュール`, content:`機能単位、交換可能な構成部分などを意味する。機器やシステムの一部を構成するひとまとまりの機能を持った部品で、システム中核部や他の部品への接合部（インターフェース）の仕様が明確に定義され、容易に追加や交換ができるようなもののことを指す。`},
{target:`シングルトン`, content:`オブジェクト指向プログラミングにおけるクラスのデザインパターンの一つで、実行時に一つしかインスタンスを作ることができないように設計。プログラム上では常に同一のインスタンスを参照するように強制することができる。`},
]
